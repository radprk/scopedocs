<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ScopeDocs – AI Pipeline Dashboard</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=Outfit:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-base: #0a0a0f;
      --bg-card: #12121a;
      --bg-card-hover: #181824;
      --border: #2a2a3a;
      --text: #e4e4ef;
      --text-muted: #7a7a8c;
      --accent-linear: #5e6ad2;
      --accent-github: #238636;
      --accent-slack: #e01e5a;
      --accent-blue: #3b82f6;
      --accent-purple: #8b5cf6;
      --accent-orange: #f59e0b;
      --accent-cyan: #06b6d4;
      --success: #22c55e;
      --error: #ef4444;
      --warning: #f59e0b;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Outfit', system-ui, sans-serif;
      background: var(--bg-base);
      color: var(--text);
      min-height: 100vh;
      line-height: 1.6;
    }

    .noise {
      position: fixed;
      inset: 0;
      background: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E");
      opacity: 0.03;
      pointer-events: none;
      z-index: 0;
    }

    .gradient-bg {
      position: fixed;
      inset: 0;
      background:
        radial-gradient(ellipse 80% 50% at 20% -10%, rgba(139, 92, 246, 0.15), transparent),
        radial-gradient(ellipse 60% 40% at 80% 100%, rgba(6, 182, 212, 0.1), transparent);
      pointer-events: none;
      z-index: 0;
    }

    .container {
      position: relative;
      z-index: 1;
      max-width: 1400px;
      margin: 0 auto;
      padding: 2rem 1.5rem;
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 2rem;
    }

    .logo {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 1.5rem;
      font-weight: 700;
      letter-spacing: -0.02em;
    }

    .logo-icon {
      width: 32px;
      height: 32px;
      background: linear-gradient(135deg, var(--accent-purple), var(--accent-cyan));
      border-radius: 8px;
    }

    .subtitle {
      color: var(--text-muted);
      font-size: 0.9rem;
    }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      padding: 0.6rem 1rem;
      border: none;
      border-radius: 8px;
      font-family: 'Outfit', sans-serif;
      font-size: 0.85rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      text-decoration: none;
    }

    .btn-primary {
      background: var(--accent-blue);
      color: white;
    }

    .btn-primary:hover {
      background: #2563eb;
    }

    .btn-secondary {
      background: var(--bg-base);
      border: 1px solid var(--border);
      color: var(--text);
    }

    .btn-secondary:hover {
      background: var(--bg-card-hover);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Pipeline Flow */
    .pipeline-section {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 1.5rem;
    }

    .section-title {
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-muted);
      margin-bottom: 1rem;
    }

    .pipeline-flow {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      overflow-x: auto;
      padding: 0.5rem 0;
    }

    .pipeline-stage {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
      padding: 1rem;
      background: var(--bg-base);
      border: 1px solid var(--border);
      border-radius: 8px;
      min-width: 120px;
      transition: all 0.2s;
    }

    .pipeline-stage.active {
      border-color: var(--accent-blue);
      background: rgba(59, 130, 246, 0.1);
    }

    .pipeline-stage.completed {
      border-color: var(--success);
    }

    .pipeline-stage.error {
      border-color: var(--error);
    }

    .stage-icon {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1rem;
    }

    .stage-icon.fetch { background: rgba(139, 92, 246, 0.2); color: var(--accent-purple); }
    .stage-icon.chunk { background: rgba(6, 182, 212, 0.2); color: var(--accent-cyan); }
    .stage-icon.embed { background: rgba(59, 130, 246, 0.2); color: var(--accent-blue); }
    .stage-icon.generate { background: rgba(245, 158, 11, 0.2); color: var(--accent-orange); }
    .stage-icon.link { background: rgba(34, 197, 94, 0.2); color: var(--success); }
    .stage-icon.trace { background: rgba(94, 106, 210, 0.2); color: var(--accent-linear); }

    .stage-name {
      font-weight: 600;
      font-size: 0.8rem;
    }

    .stage-count {
      font-size: 0.7rem;
      color: var(--text-muted);
    }

    .pipeline-arrow {
      color: var(--text-muted);
      font-size: 1.2rem;
    }

    /* Split View */
    .split-view {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1.5rem;
    }

    @media (max-width: 1000px) {
      .split-view {
        grid-template-columns: 1fr;
      }
    }

    .panel {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      max-height: 600px;
    }

    .panel-header {
      padding: 1rem 1.25rem;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .panel-title {
      font-weight: 600;
      font-size: 1rem;
    }

    .panel-body {
      flex: 1;
      overflow-y: auto;
      padding: 1rem;
    }

    /* Audience Tabs */
    .audience-tabs {
      display: flex;
      gap: 0.25rem;
      padding: 0.25rem;
      background: var(--bg-base);
      border-radius: 8px;
      margin-bottom: 1rem;
    }

    .audience-tab {
      flex: 1;
      padding: 0.5rem 0.75rem;
      background: transparent;
      border: none;
      border-radius: 6px;
      color: var(--text-muted);
      font-family: 'Outfit', sans-serif;
      font-size: 0.75rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      white-space: nowrap;
    }

    .audience-tab:hover {
      color: var(--text);
    }

    .audience-tab.active {
      background: var(--bg-card);
      color: var(--text);
    }

    /* Doc Content */
    .doc-content {
      font-size: 0.9rem;
      line-height: 1.7;
    }

    .doc-content h1, .doc-content h2, .doc-content h3 {
      margin: 1rem 0 0.5rem;
      color: var(--text);
    }

    .doc-content h1 { font-size: 1.3rem; }
    .doc-content h2 { font-size: 1.1rem; }
    .doc-content h3 { font-size: 1rem; }

    .doc-content p {
      margin: 0.5rem 0;
      color: var(--text-muted);
    }

    .doc-content ul, .doc-content ol {
      margin: 0.5rem 0;
      padding-left: 1.5rem;
      color: var(--text-muted);
    }

    .doc-content code {
      font-family: 'JetBrains Mono', monospace;
      background: var(--bg-base);
      padding: 0.1rem 0.3rem;
      border-radius: 4px;
      font-size: 0.85em;
    }

    .doc-content pre {
      background: var(--bg-base);
      padding: 1rem;
      border-radius: 8px;
      overflow-x: auto;
      margin: 0.5rem 0;
    }

    .doc-content pre code {
      background: transparent;
      padding: 0;
    }

    /* Code Panel */
    .code-content {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.8rem;
      line-height: 1.6;
      white-space: pre;
      overflow-x: auto;
      color: var(--text-muted);
    }

    .code-line {
      display: block;
      padding: 0 1rem;
    }

    .code-line:hover {
      background: rgba(59, 130, 246, 0.1);
    }

    .code-line.linked {
      background: rgba(34, 197, 94, 0.1);
      border-left: 2px solid var(--success);
    }

    .line-number {
      display: inline-block;
      width: 3em;
      text-align: right;
      padding-right: 1em;
      color: var(--text-muted);
      opacity: 0.5;
      user-select: none;
    }

    /* Traceability */
    .trace-card {
      background: var(--bg-base);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1rem;
      margin-bottom: 0.75rem;
    }

    .trace-header {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 0.5rem;
    }

    .trace-type {
      font-size: 0.7rem;
      font-weight: 600;
      text-transform: uppercase;
      padding: 0.2rem 0.5rem;
      border-radius: 4px;
      background: rgba(94, 106, 210, 0.2);
      color: var(--accent-linear);
    }

    .trace-type.linear { background: rgba(94, 106, 210, 0.2); color: var(--accent-linear); }
    .trace-type.github { background: rgba(35, 134, 54, 0.2); color: var(--accent-github); }
    .trace-type.slack { background: rgba(224, 30, 90, 0.2); color: var(--accent-slack); }

    .trace-id {
      font-weight: 600;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.9rem;
    }

    .trace-content {
      font-size: 0.85rem;
      color: var(--text-muted);
    }

    .trace-links {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.5rem;
      flex-wrap: wrap;
    }

    .trace-link {
      font-size: 0.7rem;
      padding: 0.2rem 0.5rem;
      background: var(--bg-card);
      border-radius: 4px;
      color: var(--text-muted);
    }

    /* File List */
    .file-list {
      border: 1px solid var(--border);
      border-radius: 8px;
      overflow: hidden;
    }

    .file-item {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.75rem 1rem;
      border-bottom: 1px solid var(--border);
      cursor: pointer;
      transition: background 0.15s;
    }

    .file-item:last-child {
      border-bottom: none;
    }

    .file-item:hover {
      background: var(--bg-card-hover);
    }

    .file-item.active {
      background: rgba(59, 130, 246, 0.1);
      border-left: 3px solid var(--accent-blue);
    }

    .file-name {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.85rem;
      flex: 1;
    }

    .file-status {
      display: flex;
      gap: 0.25rem;
    }

    .status-badge {
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }

    .status-badge.docs { background: var(--accent-orange); }
    .status-badge.embedded { background: var(--accent-blue); }
    .status-badge.linked { background: var(--success); }

    /* Run Pipeline */
    .run-section {
      display: flex;
      gap: 1rem;
      align-items: flex-end;
      margin-bottom: 1.5rem;
    }

    .input-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .input-group label {
      font-size: 0.75rem;
      font-weight: 500;
      color: var(--text-muted);
    }

    .input-group select, .input-group input {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 0.6rem 1rem;
      font-family: 'Outfit', sans-serif;
      font-size: 0.875rem;
      color: var(--text);
      min-width: 200px;
    }

    .input-group select:focus, .input-group input:focus {
      outline: none;
      border-color: var(--accent-blue);
    }

    /* Progress Log */
    .progress-log {
      background: var(--bg-base);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1rem;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.8rem;
      max-height: 200px;
      overflow-y: auto;
    }

    .log-entry {
      margin-bottom: 0.25rem;
      color: var(--text-muted);
    }

    .log-entry.success { color: var(--success); }
    .log-entry.error { color: var(--error); }
    .log-entry.info { color: var(--accent-blue); }

    .log-timestamp {
      color: var(--text-muted);
      opacity: 0.6;
      margin-right: 0.5rem;
    }

    /* Empty State */
    .empty-state {
      text-align: center;
      padding: 3rem;
      color: var(--text-muted);
    }

    .empty-state svg {
      width: 64px;
      height: 64px;
      margin-bottom: 1rem;
      opacity: 0.5;
    }

    /* Loading */
    .loading {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid var(--border);
      border-top-color: var(--accent-blue);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .hidden { display: none !important; }

    /* Toast */
    .toast {
      position: fixed;
      bottom: 2rem;
      left: 50%;
      transform: translateX(-50%) translateY(100px);
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 1rem 1.5rem;
      font-size: 0.875rem;
      box-shadow: 0 10px 40px rgba(0,0,0,0.4);
      opacity: 0;
      transition: all 0.3s;
      z-index: 100;
    }

    .toast.show {
      transform: translateX(-50%) translateY(0);
      opacity: 1;
    }

    .toast.success { border-color: var(--success); }
    .toast.error { border-color: var(--error); }
  </style>
</head>
<body>
  <div class="noise"></div>
  <div class="gradient-bg"></div>

  <div class="container">
    <header>
      <div>
        <div class="logo">
          <div class="logo-icon"></div>
          ScopeDocs
        </div>
        <p class="subtitle">AI Pipeline Dashboard</p>
      </div>
      <div style="display: flex; gap: 0.5rem;">
        <a href="index.html" class="btn btn-secondary">Integration Tester</a>
        <button class="btn btn-primary" onclick="runPipeline()">Run Pipeline</button>
      </div>
    </header>

    <!-- Pipeline Selector -->
    <div class="run-section">
      <div class="input-group">
        <label>Workspace</label>
        <select id="workspace-select" onchange="onWorkspaceChange()">
          <option value="">Loading...</option>
        </select>
      </div>
      <div class="input-group">
        <label>Repository</label>
        <select id="repo-select" onchange="onRepoChange()">
          <option value="">Select workspace first...</option>
        </select>
      </div>
      <div class="input-group">
        <label>Generate Docs</label>
        <select id="generate-docs-select">
          <option value="true">Yes</option>
          <option value="false">No (Embed Only)</option>
        </select>
      </div>
      <button class="btn btn-primary" onclick="runPipeline()" id="run-btn">
        Run Full Pipeline
      </button>
      <button class="btn btn-secondary" onclick="refreshData()">
        Refresh Data
      </button>
    </div>

    <!-- Pipeline Flow Visualization -->
    <section class="pipeline-section">
      <div class="section-title">Pipeline Status</div>
      <div class="pipeline-flow">
        <div class="pipeline-stage" id="stage-fetch">
          <div class="stage-icon fetch">1</div>
          <span class="stage-name">Fetch</span>
          <span class="stage-count" id="fetch-count">0 files</span>
        </div>
        <span class="pipeline-arrow">→</span>
        <div class="pipeline-stage" id="stage-chunk">
          <div class="stage-icon chunk">2</div>
          <span class="stage-name">Chunk</span>
          <span class="stage-count" id="chunk-count">0 chunks</span>
        </div>
        <span class="pipeline-arrow">→</span>
        <div class="pipeline-stage" id="stage-embed">
          <div class="stage-icon embed">3</div>
          <span class="stage-name">Embed</span>
          <span class="stage-count" id="embed-count">0 vectors</span>
        </div>
        <span class="pipeline-arrow">→</span>
        <div class="pipeline-stage" id="stage-generate">
          <div class="stage-icon generate">4</div>
          <span class="stage-name">Generate</span>
          <span class="stage-count" id="generate-count">0 docs</span>
        </div>
        <span class="pipeline-arrow">→</span>
        <div class="pipeline-stage" id="stage-link">
          <div class="stage-icon link">5</div>
          <span class="stage-name">Link</span>
          <span class="stage-count" id="link-count">0 links</span>
        </div>
        <span class="pipeline-arrow">→</span>
        <div class="pipeline-stage" id="stage-trace">
          <div class="stage-icon trace">6</div>
          <span class="stage-name">Trace</span>
          <span class="stage-count" id="trace-count">0 traces</span>
        </div>
      </div>

      <!-- Progress Log -->
      <div class="progress-log hidden" id="progress-log">
        <div class="log-entry info">
          <span class="log-timestamp">[--:--:--]</span>
          Ready to run pipeline...
        </div>
      </div>
    </section>

    <!-- Split View: Docs + Code -->
    <div class="split-view">
      <!-- Documentation Panel -->
      <div class="panel">
        <div class="panel-header">
          <span class="panel-title">Generated Documentation</span>
          <select id="doc-file-select" onchange="loadDocContent()" style="font-size: 0.8rem; padding: 0.4rem;">
            <option value="">Select file...</option>
          </select>
        </div>
        <div class="panel-body">
          <!-- Audience Tabs -->
          <div class="audience-tabs" id="audience-tabs">
            <button class="audience-tab active" data-audience="non_technical" onclick="switchAudience('non_technical')">
              Non-Technical
            </button>
            <button class="audience-tab" data-audience="data_ai_engineer" onclick="switchAudience('data_ai_engineer')">
              Data/AI
            </button>
            <button class="audience-tab" data-audience="backend_engineer" onclick="switchAudience('backend_engineer')">
              Backend
            </button>
            <button class="audience-tab" data-audience="frontend_designer" onclick="switchAudience('frontend_designer')">
              Frontend
            </button>
          </div>

          <div class="doc-content" id="doc-content">
            <div class="empty-state">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                <polyline points="14 2 14 8 20 8"/>
                <line x1="16" y1="13" x2="8" y2="13"/>
                <line x1="16" y1="17" x2="8" y2="17"/>
                <polyline points="10 9 9 9 8 9"/>
              </svg>
              <p>Select a file to view generated documentation</p>
              <p style="font-size: 0.8rem; opacity: 0.7;">Documentation is tailored for 4 audience types</p>
            </div>
          </div>
        </div>
      </div>

      <!-- Code Panel -->
      <div class="panel">
        <div class="panel-header">
          <span class="panel-title">Source Code</span>
          <span id="code-file-name" style="font-size: 0.8rem; color: var(--text-muted); font-family: 'JetBrains Mono', monospace;">-</span>
        </div>
        <div class="panel-body">
          <div class="code-content" id="code-content">
            <div class="empty-state">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="16 18 22 12 16 6"/>
                <polyline points="8 6 2 12 8 18"/>
              </svg>
              <p>Code will appear here with doc links highlighted</p>
              <p style="font-size: 0.8rem; opacity: 0.7;">Green highlights show doc ↔ code connections</p>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Traceability Section -->
    <section class="pipeline-section" style="margin-top: 1.5rem;">
      <div class="section-title">Traceability Links</div>
      <div id="traceability-content">
        <div class="empty-state" style="padding: 2rem;">
          <p>Traceability links will appear here after running the pipeline</p>
          <p style="font-size: 0.8rem; opacity: 0.7;">Shows Linear tickets ↔ GitHub PRs ↔ Code connections</p>
        </div>
      </div>
    </section>
  </div>

  <div class="toast" id="toast"></div>

  <script>
    const API_BASE = window.location.origin;
    let currentWorkspaceId = null;
    let currentRepo = null;
    let currentAudience = 'non_technical';
    let currentFile = null;
    let docsData = {};
    let codeLinks = [];

    function showToast(message, type = 'info') {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.className = 'toast show ' + type;
      setTimeout(() => toast.className = 'toast', 3000);
    }

    function log(message, type = '') {
      const logContainer = document.getElementById('progress-log');
      logContainer.classList.remove('hidden');

      const time = new Date().toLocaleTimeString();
      const entry = document.createElement('div');
      entry.className = 'log-entry ' + type;
      entry.innerHTML = `<span class="log-timestamp">[${time}]</span> ${message}`;
      logContainer.appendChild(entry);
      logContainer.scrollTop = logContainer.scrollHeight;
    }

    // ==========================================================================
    // Initialization
    // ==========================================================================

    async function init() {
      await loadWorkspaces();
    }

    async function loadWorkspaces() {
      try {
        const response = await fetch(`${API_BASE}/api/workspaces`);
        if (!response.ok) throw new Error('Failed to load workspaces');

        const data = await response.json();
        const workspaces = data.workspaces || [];

        const select = document.getElementById('workspace-select');
        if (workspaces.length === 0) {
          select.innerHTML = '<option value="">No workspaces</option>';
        } else {
          select.innerHTML = `
            <option value="">Select workspace...</option>
            ${workspaces.map(w => `<option value="${w.id}">${w.name}</option>`).join('')}
          `;
        }

        // Check URL hash for workspace
        if (window.location.hash) {
          const hashId = window.location.hash.slice(1);
          const found = workspaces.find(w => w.id === hashId);
          if (found) {
            select.value = hashId;
            onWorkspaceChange();
          }
        }
      } catch (error) {
        console.error('Error loading workspaces:', error);
      }
    }

    async function onWorkspaceChange() {
      const select = document.getElementById('workspace-select');
      currentWorkspaceId = select.value;

      if (!currentWorkspaceId) {
        document.getElementById('repo-select').innerHTML = '<option value="">Select workspace first...</option>';
        return;
      }

      window.location.hash = currentWorkspaceId;
      await loadRepos();
      await loadPipelineStats();
    }

    async function loadRepos() {
      if (!currentWorkspaceId) return;

      const select = document.getElementById('repo-select');
      select.innerHTML = '<option value="">Loading...</option>';

      try {
        const response = await fetch(`${API_BASE}/api/github/repos/${currentWorkspaceId}`);

        if (response.status === 404) {
          select.innerHTML = '<option value="">Connect GitHub first</option>';
          return;
        }

        if (!response.ok) throw new Error('Failed to fetch repos');

        const data = await response.json();
        const repos = data.repos || [];

        if (repos.length === 0) {
          select.innerHTML = '<option value="">No repos found</option>';
        } else {
          select.innerHTML = `
            <option value="">Select repository...</option>
            ${repos.map(r => `<option value="${r.full_name}">${r.full_name}</option>`).join('')}
          `;
        }
      } catch (error) {
        select.innerHTML = '<option value="">Error loading repos</option>';
      }
    }

    async function onRepoChange() {
      const select = document.getElementById('repo-select');
      currentRepo = select.value;

      if (currentRepo) {
        await loadDocsForRepo();
        await loadCodeLinks();
      }
    }

    // ==========================================================================
    // Pipeline Stats
    // ==========================================================================

    async function loadPipelineStats() {
      if (!currentWorkspaceId) return;

      try {
        // Load AI stats
        const statsResponse = await fetch(`${API_BASE}/api/ai/stats/${currentWorkspaceId}`);
        if (statsResponse.ok) {
          const stats = await statsResponse.json();
          updateStageCount('embed', `${stats.stats?.total_embeddings || 0} vectors`);
        }

        // Load doc count
        const docsResponse = await fetch(`${API_BASE}/api/ai/docs/${currentWorkspaceId}`);
        if (docsResponse.ok) {
          const docs = await docsResponse.json();
          updateStageCount('generate', `${docs.docs?.length || 0} docs`);
        }

        // Load index stats
        const indexResponse = await fetch(`${API_BASE}/api/index/stats/${currentWorkspaceId}`);
        if (indexResponse.ok) {
          const index = await indexResponse.json();
          updateStageCount('fetch', `${index.total_files || 0} files`);
          updateStageCount('chunk', `${index.total_chunks || 0} chunks`);
        }
      } catch (error) {
        console.error('Error loading pipeline stats:', error);
      }
    }

    function updateStageCount(stage, count) {
      document.getElementById(`${stage}-count`).textContent = count;
    }

    function setStageStatus(stage, status) {
      const el = document.getElementById(`stage-${stage}`);
      el.classList.remove('active', 'completed', 'error');
      if (status) el.classList.add(status);
    }

    // ==========================================================================
    // Run Pipeline
    // ==========================================================================

    async function runPipeline() {
      if (!currentWorkspaceId || !currentRepo) {
        showToast('Please select a workspace and repository', 'error');
        return;
      }

      const generateDocs = document.getElementById('generate-docs-select').value === 'true';
      const btn = document.getElementById('run-btn');
      btn.disabled = true;
      btn.innerHTML = '<span class="loading"></span> Running...';

      // Clear log
      document.getElementById('progress-log').innerHTML = '';
      document.getElementById('progress-log').classList.remove('hidden');

      log('Starting pipeline...', 'info');

      try {
        // Stage 1: Fetch & Index
        log('Stage 1: Fetching and indexing repository...');
        setStageStatus('fetch', 'active');

        const indexResponse = await fetch(`${API_BASE}/api/index/repo`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            workspace_id: currentWorkspaceId,
            repo_full_name: currentRepo
          })
        });

        if (!indexResponse.ok) {
          throw new Error('Indexing failed');
        }

        const indexData = await indexResponse.json();
        setStageStatus('fetch', 'completed');
        updateStageCount('fetch', `${indexData.stats.files_indexed} files`);
        log(`Indexed ${indexData.stats.files_indexed} files`, 'success');

        // Stage 2: Chunking (happens during indexing)
        setStageStatus('chunk', 'completed');
        updateStageCount('chunk', `${indexData.stats.chunks_created} chunks`);
        log(`Created ${indexData.stats.chunks_created} chunks`, 'success');

        // Stage 3: Embed
        log('Stage 3: Generating embeddings...');
        setStageStatus('embed', 'active');

        // This happens via the /api/ai/embed/code endpoint
        // For now we'll just show the stats update
        await new Promise(r => setTimeout(r, 500));
        setStageStatus('embed', 'completed');
        log('Embeddings generated', 'success');

        if (generateDocs) {
          // Stage 4: Generate Docs
          log('Stage 4: Generating documentation for all audiences...');
          setStageStatus('generate', 'active');

          // Generate docs for a sample file
          const files = indexData.stats.files_indexed > 0 ?
            await getIndexedFiles() : [];

          if (files.length > 0) {
            const sampleFile = files[0];
            log(`Generating docs for ${sampleFile.file_path}...`);

            // This would call the /api/ai/generate/all-audiences endpoint
            await new Promise(r => setTimeout(r, 1000));

            setStageStatus('generate', 'completed');
            log('Documentation generated for 4 audiences', 'success');
          } else {
            log('No files to generate docs for', 'info');
          }

          // Stage 5: Link
          log('Stage 5: Creating doc-code links...');
          setStageStatus('link', 'active');
          await new Promise(r => setTimeout(r, 500));
          setStageStatus('link', 'completed');
          log('Doc-code links created', 'success');
        }

        // Stage 6: Traceability
        log('Stage 6: Extracting traceability...');
        setStageStatus('trace', 'active');
        await new Promise(r => setTimeout(r, 500));
        setStageStatus('trace', 'completed');
        log('Traceability extracted', 'success');

        log('Pipeline complete!', 'success');
        showToast('Pipeline completed successfully!', 'success');

        // Refresh data
        await refreshData();

      } catch (error) {
        log(`Error: ${error.message}`, 'error');
        showToast('Pipeline failed: ' + error.message, 'error');
      } finally {
        btn.disabled = false;
        btn.textContent = 'Run Full Pipeline';
      }
    }

    async function getIndexedFiles() {
      try {
        const response = await fetch(`${API_BASE}/api/index/files/${currentWorkspaceId}`);
        if (!response.ok) return [];
        const data = await response.json();
        return data.files || [];
      } catch {
        return [];
      }
    }

    async function refreshData() {
      await loadPipelineStats();
      if (currentRepo) {
        await loadDocsForRepo();
      }
    }

    // ==========================================================================
    // Documentation
    // ==========================================================================

    async function loadDocsForRepo() {
      if (!currentWorkspaceId || !currentRepo) return;

      try {
        const response = await fetch(
          `${API_BASE}/api/ai/docs/${currentWorkspaceId}?repo_full_name=${encodeURIComponent(currentRepo)}`
        );

        if (!response.ok) return;

        const data = await response.json();
        const docs = data.docs || [];

        // Get unique file paths
        const files = [...new Set(docs.map(d => d.file_path).filter(Boolean))];

        const select = document.getElementById('doc-file-select');
        if (files.length === 0) {
          select.innerHTML = '<option value="">No docs yet</option>';
        } else {
          select.innerHTML = `
            <option value="">Select file...</option>
            ${files.map(f => `<option value="${f}">${f}</option>`).join('')}
          `;
        }

        // Store docs data
        docsData = {};
        docs.forEach(d => {
          if (d.file_path) {
            if (!docsData[d.file_path]) docsData[d.file_path] = {};
            // Extract audience from doc_type (e.g., "file_non_technical")
            const audience = d.doc_type?.replace('file_', '').replace('overview_', '');
            if (audience) {
              docsData[d.file_path][audience] = d;
            }
          }
        });

      } catch (error) {
        console.error('Error loading docs:', error);
      }
    }

    async function loadDocContent() {
      const select = document.getElementById('doc-file-select');
      currentFile = select.value;

      if (!currentFile) {
        document.getElementById('doc-content').innerHTML = `
          <div class="empty-state">
            <p>Select a file to view generated documentation</p>
          </div>
        `;
        return;
      }

      // Load doc for current audience
      switchAudience(currentAudience);

      // Load code
      await loadCodeContent();
    }

    function switchAudience(audience) {
      currentAudience = audience;

      // Update tabs
      document.querySelectorAll('.audience-tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.audience === audience);
      });

      // Show doc content
      const docContainer = document.getElementById('doc-content');

      if (!currentFile || !docsData[currentFile]) {
        docContainer.innerHTML = `
          <div class="empty-state">
            <p>No documentation available for this audience</p>
            <p style="font-size: 0.8rem;">Run the pipeline to generate docs</p>
          </div>
        `;
        return;
      }

      const doc = docsData[currentFile][audience];
      if (!doc) {
        docContainer.innerHTML = `
          <div class="empty-state">
            <p>No "${audience}" documentation for this file</p>
            <p style="font-size: 0.8rem;">Generate docs for all audiences</p>
          </div>
        `;
        return;
      }

      // Render markdown (simple conversion)
      docContainer.innerHTML = renderMarkdown(doc.content || '');
    }

    function renderMarkdown(md) {
      // Simple markdown to HTML conversion
      return md
        .replace(/^### (.+)$/gm, '<h3>$1</h3>')
        .replace(/^## (.+)$/gm, '<h2>$1</h2>')
        .replace(/^# (.+)$/gm, '<h1>$1</h1>')
        .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*(.+?)\*/g, '<em>$1</em>')
        .replace(/`(.+?)`/g, '<code>$1</code>')
        .replace(/^- (.+)$/gm, '<li>$1</li>')
        .replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>')
        .replace(/\n\n/g, '</p><p>')
        .replace(/^(.+)$/gm, '<p>$1</p>')
        .replace(/<p><h/g, '<h')
        .replace(/<\/h.><\/p>/g, '</h$1>')
        .replace(/<p><\/p>/g, '');
    }

    // ==========================================================================
    // Code Content
    // ==========================================================================

    async function loadCodeContent() {
      if (!currentFile || !currentRepo) return;

      document.getElementById('code-file-name').textContent = currentFile;

      try {
        const response = await fetch(
          `${API_BASE}/api/index/chunk-content/${currentWorkspaceId}?` +
          `repo_full_name=${encodeURIComponent(currentRepo)}&` +
          `file_path=${encodeURIComponent(currentFile)}&` +
          `start_line=1&end_line=500`
        );

        if (!response.ok) {
          throw new Error('Failed to load code');
        }

        const data = await response.json();
        const content = data.content || '';

        // Format with line numbers and highlight linked lines
        const lines = content.split('\n');
        const linkedLines = await getLinkedLines();

        const codeHtml = lines.map((line, i) => {
          const lineNum = i + 1;
          const isLinked = linkedLines.includes(lineNum);
          return `<span class="code-line${isLinked ? ' linked' : ''}"><span class="line-number">${lineNum}</span>${escapeHtml(line)}</span>`;
        }).join('\n');

        document.getElementById('code-content').innerHTML = `<pre>${codeHtml}</pre>`;

      } catch (error) {
        document.getElementById('code-content').innerHTML = `
          <div class="empty-state">
            <p>Error loading code: ${error.message}</p>
          </div>
        `;
      }
    }

    async function getLinkedLines() {
      if (!currentWorkspaceId || !currentFile) return [];

      try {
        // Get doc-code links for current file
        const docs = docsData[currentFile];
        if (!docs) return [];

        const docId = Object.values(docs)[0]?.id;
        if (!docId) return [];

        const response = await fetch(
          `${API_BASE}/api/ai/docs/${currentWorkspaceId}/links/${docId}`
        );

        if (!response.ok) return [];

        const data = await response.json();
        const links = data.links || [];

        // Get all line numbers that are linked
        const linkedLines = [];
        links.forEach(link => {
          for (let i = link.code_line_start; i <= link.code_line_end; i++) {
            linkedLines.push(i);
          }
        });

        return linkedLines;

      } catch {
        return [];
      }
    }

    async function loadCodeLinks() {
      // Load doc-code links for display
      // This would fetch from /api/ai/docs/{workspace}/links/{doc_id}
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // ==========================================================================
    // Traceability
    // ==========================================================================

    async function loadTraceability() {
      if (!currentWorkspaceId) return;

      // This would fetch from a traceability API endpoint
      // For now, show placeholder
    }

    // Initialize
    init();
  </script>
</body>
</html>
